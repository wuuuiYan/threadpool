## 问题准备

### **:rocket: 并发与并行有何区别？**

- 单核上，多个线程占用该CPU的不同时间片，通过CPU调度算法实现不同任务间的切换，但**物理上还是串行执行的**。由于每个线程占用的CPU时间片非常短，看起来就像是多个线程都在共同执行一样，这样的场景称作并发(concurrent)
- 在多CPU上，不同的CPU执行不同的任务，在一个任务完成之前不存在与其他任务在同一CPU上的切换，**实现多个任务真正同时进行**，这样的场景称作并行(parallel)

### **:rocket: 线程越多越好吗？为什么？**

- **IO密集型：程序里面的指令涉及IO操作，例如设备、文件、网络操作等；CPU密集型：程序中的指令都是做计算用的**
- 线程不是越多越好，需要结合具体的应用场景分析：对于IO密集型程序，由于**IO密集型程序在等待输入输出操作或客户端连接时可以阻塞程序，所以最好使用多线程**。对于CPU密集型程序，若当前运行环境为多核，使用多线程可以加快运行速度；若当前运行环境为单核，使用多线程反而会降低运行速度，因为线程的切换、栈内存的恢复也需要消耗资源，此时最好使用单线程
- 线程的创建与销毁都需要消耗资源，例如用户空间到内核空间的切换、线程的内核栈的创建、页表与页目录的创建、描述进程的地址空间的数据结构的初始化等，线程越多，这些资源消耗越大。**因此尽量不要在服务的过程中实时地创建或销毁线程**。线程的切换也需要消耗资源，例如线程的上下文切换、线程的调度等，线程越多，这些资源消耗越大，进而导致CPU的利用率下降
- 当创建线程之后，**线程函数所在的线程栈需要共享当前所在进程的用户空间(3G)**，此时若创建大量的线程(大约最多可创建380个线程)，会导致内存空间不足，从而导致程序崩溃。若大量线程同时被唤醒会使系统出现锯齿状负载或者瞬间负载量很大，导致宕机
- 一般在使用过程中，线程数量是依据当前运行系统下的CPU核心数(hardware_concurrency()函数)来确定的，例如CPU核数为4，则线程数量一般为4

### **:rocket: 谈一下你了解的多线程/多进程编程**

- 多线程编程：在一个进程中创建多个线程，每个线程执行不同的任务，从而实现多任务并行执行的效果
- 多进程编程：在一个进程中创建多个子进程，每个子进程执行不同的任务，从而实现多任务并行执行的效果
- 在Linux操作系统下可以调用`fork`函数创建子进程，也可以调用`pthread_create`函数创建子线程；而在C++语言中，自C++11才开始推出了多线程库，现在一般使用`std::thread`类创建子线程
- **在Linux操作系统下，任务间通讯与同步方式大致可以分为两大类：管道(有名/无名)、socket套接字、消息队列、共享内存共四种通讯方式，信号量、互斥锁、信号共三种同步方式**
- 共享内存：多个进程共享一段内存，进程间通讯最快的方式，但是没有同步机制，需要自己实现；把这段内存空间映射到多个进程(有无血缘关系均可)，某一进程对这段内存的操作都会影响到其他进程；常用函数：创建共享内存、建立映射关系、解除映射关系、删除共享内存
- 消息队列：是一种以结构体为载体的数据容器；消息队列是一个消息链表，存放在内核中，进程间通讯的方式，可以实现进程间(有无血缘关系均可)的同步；常用函数：创建消息队列、发送消息、接收消息、删除消息队列
- 信号量：是一个由内核维护的>=0的整数，用来表示某种资源的数量，具有排他性，可以用来实现进程间的同步
- 无名信号量：是一个计数器，用来控制多个进程对共享资源的访问；信号量是一个整数，用来表示某种资源的数量，可以用来实现进程间的同步；常用函数：创建信号量、初始化信号量、P操作、V操作、删除信号量
- 互斥锁：可以理解为只能加锁或解锁的信号量；更多的用在线程之间的同步，而不是进程之间的同步；互斥锁是一个结构体，用来实现进程间的同步；常用函数：创建互斥锁、初始化互斥锁、加锁、解锁、删除互斥锁
- 信号：内核与应用进程之间或应用程序与应用程序之间传递控制的命令，而不是传递数据；信号是一种异步通知机制，可以用来实现进程间的同步；常用函数：发送信号、捕捉信号、忽略信号
- **C++语言中，线程间同步的方式大致可分为互斥与通信两种，互斥指的是多个线程执行同一段代码，但不能同时执行，通信指的是不同线程执行不同的代码，彼此之间有条件依赖。互斥锁`mutex`类、`atomic`原子类型用于实现线程互斥(多个线程运行同一段代码)，条件变量`condition_variable`类、信号量`semaphore`(C++20)用于实现线程通信(多个线程运行各自的相互联系的代码)**
- 线程通信中，条件变量`condition_variable`与互斥锁`mutex`配合使用，控制更加精细；**信号量`semaphore`可以看作是资源计数没有限制的互斥锁`mutex`，只能粗略控制执行的先后顺序，对于具有竟态条件的代码段无法实现原子操作(关键原因是资源计数没有限制)**
- 还有一种二元信号量`semaphore`，可以看作是资源计数只能为0或1的互斥锁`mutex`，可以完成和`mutex`互斥锁同样的线程互斥操作。**二者的区别在于：`mutex`只能由加锁的线程解锁，而发布信号量`post()`成员函数、等待信号量`wait()`成员函数都可以由任意线程调用，可能会存在一个线程还未执行完毕另一个线程就又获得了资源计数，所以还是具有信号量无法实现原子操作的固有缺点**

### **:rocket: 多线程专业术语汇总**

- 一段代码能否在多线程环境下执行，取决于这段代码是否存在竟态条件
- 竟态条件：多个线程同时访问同一块资源，且最终的结果取决于线程执行的顺序
- 如果在多线程环境下存在竟态条件，则是多线程可重入(一个线程没有运行完另一个线程又调用)的；反之是不可重入的
- 临界区：多个线程同时访问的共享资源，且存在竟态条件的代码段，需要用到线程互斥方法保证其原子操作
- 对于存在竟态条件但比较简单的代码段，可以不使用互斥锁，而使用原子类型`atomic`来实现线程互斥，效率更高
- **分析多线程问题时，绝对不能假设线程的运行时序，但可以在逻辑上要求运行的先后顺序**

### **:rocket: 描述一下生产者消费者模型**

- **生产者消费者模型是C++多线程通信模型中的典型案例**，具体使用场景可以分为先生产后消费或生产一个消费一个两种
- 在这个模型中，生产者与消费者均使用`unique_lock`模板类(该类提供了`lock`与`unlock`成员函数，不能使用`lock_guard`类)与互斥锁`mutex`配合使用创建互斥量，通过`condition_variable`类创建条件变量
- 当生产者生产完毕后，通过条件变量的`notify_all`方法通知消费者；当消费者消费完毕后，通过条件变量的`wait`方法等待生产者通知
- 执行`wait`函数时，**线程会先把互斥锁释放，因此不会造成死锁现象，同时线程状态由`running`变为`waiting`**，并且等待条件变量的通知；当收到通知后，线程状态由`waiting`变为`blocking`，**此时若互斥锁已被解锁，线程状态才有可能(取决于接下来线程的执行顺序)会由`blocking`变为`running`，继续执行，否则将继续阻塞在此处**
- 类似的，执行`notify_all`或`notify_one`函数时，线程只是发出通知，此时有没有其他线程接收并不重要，**接收到通知的线程只是从`waiting`状态变为`blocking`状态，一般要等待线程函数运行完毕，自动调用析构函数释放互斥锁之后，接收到通知的线程状态才有可能(取决于接下来线程的执行顺序)由`blocking`变为`running`，继续执行**
- **在本项目中，用户是任务的生产者，线程是任务的消费者，不同的线程(用户线程、线程池线程)读取同一个任务队列，需要考虑任务队列(STL容器)的线程安全问题**

### **:rocket: 该项目的应用场景有哪些，为什么有这个需求**

- 在服务进程启动之初，就事先创建好线程池里面的线程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行 task 任务即可，task 执行完成后，**也不用释放线程，而是把线程归还到线程池中继续给后续的 task 提供服务**，这样就避免了线程的实时频繁创建与销毁，提高了程序的性能
- 同时线程池也最大化利用了硬件多核的优势
- fixed 模式下：**线程池里面的线程个数是固定不变的**，一般是ThreadPool创建时根据当前机器的CPU核心数量进行指定
- cached 模式下：**线程池里面的线程个数是可动态增长的**，根据任务的数量动态的增加线程的数量，但是会设置一个线程数量的阈值(线程过多的坏处上面已经讲过了)，任务处理完成，如果动态增长的线程空闲了60s还没有处理其它任务，那么关闭线程、保持池中最初数量的线程即可

### **:rocket: 项目中用到了哪些重要知识点**

- 在实现任务队列(std::queue)时，使用`shared_ptr`智能指针，可以避免用户传入一个匿名的任务对象，导致任务队列中存储的任务对象被提前销毁，进而导致的内存泄漏问题
- 在用户提交的任务需要继承`Task`基类实现自定义的任务类，并在其中重写`run`纯虚函数；线程池中存放任务的队列(std::queue)存放的是基类类型的智能指针，这样用户在使用时，可以让该智能指针指向派生类的对象；具体调用时，根据智能指针所指向的派生类的对象类型，调用不同的重写函数，从而实现多态
- 因为各线程函数在执行时要保证竟态条件，所以需要用到互斥锁与条件变量，将具体的线程函数定义在`ThreadPool`类中；在创建线程对象时，调用标准库函数`bind()`，生成一个可调用线程函数`threadFunc()`的匿名可调用对象，传递给`Thread`类的构造函数，`make_unique()`函数生成指向`Thread`类对象的智能指针，从而实现线程的创建
- 在用C++11实现`Any`类型时，使用了模板类与多态的结合。`Any`类中包含具有继承关系的类型，其中派生类还使用了类模板实现其构造函数，这样就可以实现使用任意类型构造；然后在`Any`类型的成员变量中又包含了一个基类类型的智能指针，这样就可以指向派生类的对象，实现多态。这里其实是委托设计思想：一个类中含有指向另一个类的指针，这样就可以调用另一个类的成员函数
- 借助互斥锁与条件变量，手动实现了`Semaphore`类，成员变量中增加了一个表示资源计数的整形常量

### **:rocket: 项目中死锁问题复现，如何解决**