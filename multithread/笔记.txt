多核处理器 --> 并发操作

在C++11之后，标准库提供了并发操作的支持，包括线程、原子操作、互斥量、条件变量等等

并发分类：
    软件并发指的是在一个时间段内，宏观上有多个程序同时运行，本质上是任务间高速切换，而微观上在某个时间点上只有一个程序在运行
    硬件并发指的是在一个时间段内，有多个程序同时运行在不同的处理器核心上

理想情况：硬件核心数 >= 待处理任务数，但实际情况常常是硬件并发与软件并发/任务切换同时存在

并发方式：
    多进程并发：多个进程同时运行，每个进程有自己的地址空间，之间互不影响，
               进程间通信需要借助操作系统提供的IPC机制，且硬件开销(启动、加载、释放)比较大
    多线程并发：多个线程同时运行，同一个进程之内的每个线程都共享进程的地址空间，线程间通信更加方便
               线程间的调度与切换开销较小，但需要开发者自己保证线程安全
    目前为止，多线程并发是大多数主流编程语言最常用的并发方式，因此本课程也是基于C++的多线程并发编程

并不是任何情况下都需要使用多线程开发，多线程开发的优势在于：
    1.提高程序的响应速度，增强用户体验
    2.提高程序的可扩展性，方便程序的后期维护
    3.提高程序的运行效率，充分利用多核处理器的优势

创建线程的方式：
    函数指针、函数对象/函数符/仿函数、lambda表达式、成员函数指针、类成员函数
    根本原因是由于 thread 类中有多种形式的构造函数，传递不同参数就可调用不同构造函数


thread_local：线程本地存储
move函数：线程移动操作，将一个线程移动到另外一个线程，则原线程会被销毁
joinable函数：判断线程是否可以能够汇合/被join，可以汇合返回true，无法汇合返回false
             执行过move操作的线程无法被join，执行过join/detach操作的线程无法再次join，默认构造的线程无法被join
RAII：是一种对资源申请、资源释放成对的操作的封装，https://zhuanlan.zhihu.com/p/34660259
hardware_concurrency函数：获取当前系统的CPU核心数

互斥锁：lock加锁 unlock解锁 但在实际使用中常常忘记解锁
        在实际编程中多使用lock_guard模板类，该类的构造函数上锁，析构函数解锁
死锁：某一线程一直不解锁导致另一线程无法执行或两个线程互相等待对方释放锁导致程序都无法继续执行
        1.避免一个线程同时获取多个锁
        2.避免一个线程在锁内部占有多个资源，尽量保证一个锁只占用一个资源
        3.尝试使用定时锁，使用lock.try_lock_for()来替代使用lock()尝试锁定资源，超时后进行其他处理
        4.对于数据库锁等特殊情况，确保锁定的资源都是相同的顺序
        5.尽量使用std::lock()来锁定多个互斥量，而不是分开锁定

unique_lock模板类：使用比lock_guard模板类灵活，可选功能更多，但执行效率较低
                  lock_guard类在构造函数中自动加锁，在析构函数中自动解锁，这是它的优点
                  unique_lock类可以选择在构造函数中加锁/不加锁，若在构造函数中传参defer_lock，则需要手动调用成员函数lock进行加锁操作
                        可以在类对象被销毁时自动解锁，可以调用成员函数手动解锁，这是它的优点
                        
scoped_lock模板类：构造函数为可变参数模板，可以指定多个互斥量同时锁定，也可以在析构函数同时解锁

同步(synchronize)：某个线程必须等待另外一个线程执行完毕或发出信号后才能继续执行
异步(asynchronize)：线程之间的执行不需要等待另外的线程的执行结果，可以同时执行
async()函数：只是创建任务对象，不一定会创建新线程，只有当任务是异步任务时才创建对应的新线程